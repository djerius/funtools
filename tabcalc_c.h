
#include "chunked.h"

ChunkedString TABCALC_C = {
  9,
  { "/*\n *\n * This program was generated automatically by the funcalc program,\n * by running the tabcalc.c template through the funcalc.l lexical analyzer.\n * On this system, it was (or can be) built a command such as:\n *\n * $COMMAND\n *\n */\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include \"funtools.h\"\n#include \"word.h\"\n#include \"NaN.h\"\n\nextern char *optarg;\nextern int optind;\n\n/* define the types of event records we have to handle */\n#define REC_CUR\t\t1\n#define REC_PREV\t2\n#define REC_NEXT\t4\n\n#define ARGC     __nxarg\n#define ARGV(n) ((__xargs && (n>=0) && (n<__nxarg)) ? __xargs[n] : NULL)\n\n#define I __i\n#define NROW __nrow\n#define WRITE_ROW FunTableRowPut(ofun, (char *)cur, 1, __i, NULL)\n\n/* default number of rows to read at a time */\n#define MAXROW 8192\nint __maxrow = MAXROW;\n\n/* floating check for equality */\n#ifndef feq\n#define feq(x,y)\t(fabs((double)x-(double)y)<=(double)1.0E-15)\n/* avoid divide by zero */\n#ifndef div\n#define div(a,b) (feq(b,0)?(getnand())",
":(a/b))\n#endif\n#endif\n\ntypedef struct rowstruct {\n    $MEMBERS int __ncol;\n}  *Row,\n    RowRec;\n\n/* global definitions and init calls go here */\n$GLOBAL\n/* main program */\n    int\nmain(\n    int argc,\n    char **argv\n ) {\n    int __c, __i;\n    int __get, __got, __total, __rectype, __args;\n    int __saved = 0;\n    int __del = 0;\n    int __nxarg = 0;\n    int __ip = 0;\n    int __nrow = -1;\n    int __rawsize = 0;\n    char *__s;\n    char *__cols = NULL;\n    char *__argstr = NULL;\n    char *__rawsave = NULL;\n    char *__rawbuf = NULL;\n    char **__xargs = NULL;\n    char __tbuf[SZ_LINE];\n    Row __rowbuf, __rowrptr, __rowsptr, __roweptr;\n    Row cur, prev, next;\n    Fun fun, ofun;\n    off_t __opos;\n    $AUTO\n        /* local definitions, followed by init calls, go here */\n        $LOCAL\n        /* exit on gio errors */\n        if ( !getenv( \"GERROR\" ) )\n\tsetgerror( 2 );\n\n    /* avoid shared library problems by using \"process\" type for filtering */\n    putenv( \"FILTER_PTYPE=process\" );\n\n    /* process switch arguments",
" */\n    while ( ( __c = getopt( argc, argv, \"a:d\" ) ) != -1 ) {\n\tswitch ( __c ) {\n\t    case 'a':\n\t\t__argstr = xstrdup( optarg );\n\t\tbreak;\n\t    case 'd':\n\t\t__del = 1;\n\t\tbreak;\n\t}\n    }\n\n    /* check for required arguments */\n    __args = argc - optind;\n    /* make sure we have minimal arguments */\n    if ( __args < $ARGS ) {\n\tif ( $ARGS == 1 )\n\t    fprintf( stderr, \"usage: %s iname\\n\", argv[0] );\n\telse\n\t    fprintf( stderr, \"usage: %s iname oname [cols]\\n\", argv[0] );\n\tgoto error;\n    }\n\n    /* set passed arguments in __xargs array */\n    if ( __argstr && *__argstr ) {\n\t__xargs = calloc( SZ_LINE, sizeof( char * ) );\n\twhile ( word( __argstr, __tbuf, &__ip ) ) {\n\t    if ( __nxarg >= SZ_LINE ) {\n\t\tgerror( stderr, \"too many args passed via -a\\n\" );\n\t\tgoto error;\n\t    }\n\t    __xargs[__nxarg++] = xstrdup( __tbuf );\n\t}\n    }\n\n    /* set rectype: determine whether we need prev,next records */\n    __rectype = $RECTYPE;\n\n    /* get maxrow,if user-specified */\n    if ( ( __s = ( char * ) getenv( \"FUN_MAXROW\" ) ) != NULL ",
")\n\t__maxrow = atoi( __s );\n    /* make sure max row is large enough to handle prev, next */\n    if ( __rectype & ( REC_PREV | REC_NEXT ) )\n\t__maxrow = MAX( 3, __maxrow );\n    else\n\t__maxrow = MAX( 1, __maxrow );\n    /* this is what we read each time */\n    __get = __maxrow;\n\n    /* open input file */\n    if ( !( fun = FunOpen( argv[optind + 0], \"rc\", NULL ) ) ) {\n\tgerror( stderr, \"could not FunOpen input file: %s\\n\", argv[optind + 0] );\n\tgoto error;\n    }\n\n    /* open the output FITS image, inheriting params from input */\n    if ( $ARGS > 1 ) {\n\tif ( !( ofun = FunOpen( argv[optind + 1], \"w\", fun ) ) ) {\n\t    gerror( stderr, \"could not FunOpen output file: %s\\n\", argv[optind + 1] );\n\t    goto error;\n\t}\n    }\n\n    /* select columns */\n    FunColumnSelect( fun, sizeof( RowRec ), \"merge=$MERGE\",\n                     $SELECT \"$N\", \"1J\", \"r\", FUN_OFFSET( Row, __ncol ), NULL );\n\n    /* activate specified columns -- these will be written to the output file */\n    if ( __args >= 3 ) __cols = argv[optind + 2];\n    FunC",
"olumnActivate( fun, __cols, NULL );\n\n    /* allocate space for __rowbuf -- we will manage this buffer ourselves */\n    /* NB: we need 2 extra rows for prev and next */\n    __rowbuf = ( Row ) xcalloc( __maxrow + 2, sizeof( RowRec ) );\n\n    /* get size of raw data record and allocate a raw record */\n    FunInfoGet( fun, FUN_RAWSIZE, &__rawsize, 0 );\n    __rawsave = ( char * ) xcalloc( 1, __rawsize );\n\n    /*  no record read yet */\n    __total = 0;\n\n    /* any user-defined calls before we enter the row loop go here */\n    $BEFORE\n        /* main loop -- get rows and process */\n        while ( 1 ) {\n\tif ( !( __rectype & ( REC_PREV | REC_NEXT ) ) ) {\n\t    /* offset of next record to process */\n\t    __rowsptr = __rowbuf;\n\t    __rowrptr = __rowbuf;\n\t}\n\t/* need prev record */\n\telse if ( __rectype & REC_PREV ) {\n\t    /* no records yet: read new batch of records into start of __rowbuf */\n\t    if ( __total == 0 ) {\n\t\t__rowsptr = __rowbuf + 1;\n\t\t__rowrptr = __rowbuf;\n\t    }\n\t    /* read last processed record into start o",
"f __rowbuf, process others */\n\t    else {\n\t\tif ( __rectype & REC_NEXT ) {\n\t\t    memcpy( __rowbuf, __rowrptr + ( __got - 2 ), sizeof( RowRec ) * 2 );\n\t\t    __rowsptr = __rowbuf + 1;\n\t\t    __rowrptr = __rowbuf + 2;\n\t\t    /* save raw data for this unprocessed record */\n\t\t    FunInfoGet( fun, FUN_RAWBUF, &__rawbuf, 0 );\n\t\t    memcpy( __rawsave, __rawbuf + ( ( __got - 1 ) * __rawsize ), __rawsize );\n\t\t}\n\t\telse {\n\t\t    memcpy( __rowbuf, __rowrptr + ( __got - 1 ), sizeof( RowRec ) );\n\t\t    __rowsptr = __rowbuf + 1;\n\t\t    __rowrptr = __rowbuf + 1;\n\t\t}\n\t    }\n\t}\n\t/* if we did not process last record, seek to it now and start there */\n\telse if ( __rectype & REC_NEXT ) {\n\t    /* no records yet: read new batch of records into start of __rowbuf */\n\t    if ( __total == 0 ) {\n\t\t__rowsptr = __rowbuf;\n\t\t__rowrptr = __rowbuf;\n\t    }\n\t    /* read last processed record into first new record, process others */\n\t    else {\n\t\tmemcpy( __rowbuf, __rowrptr + ( __got - 1 ), sizeof( RowRec ) );\n\t\t__rowsptr = __rowbuf;\n\t\t__rowrptr = __ro",
"wbuf + 1;\n\t\t/* save raw data for this unprocessed record */\n\t\tFunInfoGet( fun, FUN_RAWBUF, &__rawbuf, 0 );\n\t\tmemcpy( __rawsave, __rawbuf + ( ( __got - 1 ) * __rawsize ), __rawsize );\n\t    }\n\t}\n\n\t/* read new rows */\n\tif ( !FunTableRowGet( fun, __rowrptr, __get, NULL, &__got )\n\t     || !__got )\n\t    break;\n\n\t/* last record to process */\n\t__roweptr = __rowrptr + __got;\n\t/* if we need access to next record, don't process the last one we read */\n\tif ( __rectype & REC_NEXT ) {\n\t    __roweptr--;\n\t}\n\n\t/* make sure there are rows to process */\n\tif ( ( __roweptr - __rowsptr ) <= 0 ) break;\n\n\t/* process all rows */\n\tfor ( cur = __rowsptr, __i = __rowsptr - __rowrptr; cur < __roweptr; cur++, __i++ ) {\n\t    /* save raw buffer and switch rawbuf from previous */\n\t    if ( __i == -1 ) {\n\t\tFunInfoGet( fun, FUN_RAWBUF, &__rawbuf, 0 );\n\t\tFunInfoPut( fun, FUN_RAWBUF, &__rawsave, 0 );\n\t\t__i = 0;\n\t\t__saved = 1;\n\t    }\n\t    /* restore raw buffer */\n\t    else if ( __saved ) {\n\t\tFunInfoPut( fun, FUN_RAWBUF, &__rawbuf, 0 );\n\t\t__i = 0;",
"\n\t\t__saved = 0;\n\t    }\n\t    /* finished another row */\n\t    NROW++;\n\t    /* set up pointer to prev and next as needed */\n\t    if ( __rectype & REC_PREV ) prev = cur - 1;\n\t    if ( __rectype & REC_NEXT ) next = cur + 1;\n\t    /* execute the expression */\n\t    $EXPR\n\t        /* write out this row with the new column */\n\t        if ( $ARGS > 1 ) WRITE_ROW;\n\t}\n\t/* update total */\n\t__total += __got;\n    }\n\n    /* any user-defined calls after we finish the row loop go here */\n    $AFTER\n        /* free row data */\n        if ( __rowbuf ) xfree( __rowbuf );\n    if ( __rawsave ) xfree( __rawsave );\n\n    /* free arg strings */\n    if ( __xargs ) {\n\tfor ( __i = 0; __i < __nxarg; __i++ ) {\n\t    if ( __xargs[__i] ) xfree( __xargs[__i] );\n\t}\n\txfree( __xargs );\n    }\n\n    /* clean up -- close output before input to perform flush automatically */\n    if ( $ARGS > 1 )\n\tFunClose( ofun );\n    FunClose( fun );\n\n    /* delete program if necessary */\n    if ( __del ) unlink( argv[0] );\n    return ( 0 );\n\n  error:\n    /* delete pro",
"gram if necessary */\n    if ( __del ) unlink( argv[0] );\n    return ( 1 );\n}\n" }
};

