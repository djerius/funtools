
#include "chunked.h"

ChunkedString EVENTS_C = {
  7,
  { "/* gcc -g -o foo event.body.c -lm */\n#ifdef TEST\n#include <math.h>\n#define EVFILTRTN _FilterEvents\n#define NSHAPE 1\n#define NREGION 1\n#define _X_ X\n#define _Y_ Y\n#define FILTER ((circle(g,1,1,1,_X_,_Y_,1,2,3)))\n#define EVSIZE 4\n#define X *((short *)(eptr+0))\n#define Y *((short *)(eptr+2))\n#include \"regions.h\"\n#endif\n\nstatic char __abuf[EVSIZE + 1];\nstatic char *\nacopy(\n    void *s,\n    int n\n ) {\n    memset( __abuf, 0, n + 1 );\n    memmove( __abuf, s, n );\n    return __abuf;\n}\n\nvoid *\nEVFILTRTN(\n    void *tg,\n    char *ebuf,\n    int ne,\n    int esize,\n    int *rbuf\n ) {\n    int i, j;\n    int *rptr;\n    char *eptr;\n    Scan scan, tscan;\n    GFilt g = ( GFilt ) tg;\n\n    /* set eptr to ebuf -- this must be done before FINIT, because the latter */\n    /*passes X and Y to shape init routines, and these defines use eptr */\n    eptr = ebuf;\n\n    if ( !g ) {\n\tg = ( GFilt ) calloc( 1, sizeof( GFiltRec ) );\n#if NSHAPE\n\t/* allocate space for the globals */\n\tg->nshapes = NSHAPE;\n\tg->maxshapes = ( NSHAPE * ( XSNO + 1 ) ) ",
"+ 1;\n\tg->shapes = ( Shape ) calloc( g->maxshapes, sizeof( ShapeRec ) );\n#endif\n#ifdef EVSECT\n\t/* if evsect is defined, we are filtering an image section */\n\tg->evsect = EVSECT;\n\tsscanf( g->evsect, \"%d %d %d %d %d\", &g->xmin, &g->xmax, &g->ymin, &g->ymax, &g->block );\n\t/* get x and y limits on subsection */\n\tg->x0 = 1;\n\tg->y0 = 1;\n\tg->x1 = ( g->xmax - g->xmin ) / g->block + 1;\n\tg->y1 = ( g->ymax - g->ymin ) / g->block + 1;\n\t/* allocate a buffer for valid y row flags */\n\tg->ybuf = ( int * ) calloc( g->y1 + 1, sizeof( int ) );\n\tg->x0s = ( int * ) calloc( g->y1 + 1, sizeof( int ) );\n\tg->x1s = ( int * ) calloc( g->y1 + 1, sizeof( int ) );\n\t/* seed impossible values for x limits */\n\tfor ( i = 0; i <= g->y1; i++ ) g->x0s[i] = g->x0;\n\tfor ( i = 0; i <= g->y1; i++ ) g->x1s[i] = g->x1;\n\t/* save image mask values */\n\tif ( NMASK ) {\n\t    g->nmask = NMASK;\n\t    g->maskdim = MASKDIM;\n\t    g->masks = _masks;\n\t}\n\t/* initialize shapes -- but check to make sure eptr is OK */\n#if DO_FILTER_SWAP\n\tmemset( _swf, 0, EVSIZE );\n#endi",
"f\n\tif ( eptr ) FINIT;\n\t/* these also must be defined if EVSECT is being used */\n\tg->tlminx = TLMINX;\n\tg->tlminy = TLMINY;\n\tg->usebinsiz = USEBINSIZ;\n\tif ( BINSIZX > 0.0 )\n\t    g->binsizx = BINSIZX;\n\telse\n\t    g->binsizx = 1.0;\n\tif ( BINSIZY > 0.0 )\n\t    g->binsizy = BINSIZY;\n\telse\n\t    g->binsizy = 1.0;\n\tg->tloff = TLOFF;\n#endif\n    }\n\n    /* if we have negative events, we free the structs */\n    if ( !ebuf && !rbuf && ( ne < 0 ) ) {\n#if NSHAPE\n\t/* free polygon records */\n\tfor ( i = 0; i < g->maxshapes; i++ ) {\n\t    if ( g->shapes[i].scanlist ) {\n\t\tfor ( j = 0; j < g->y1; j++ ) {\n\t\t    if ( g->shapes[i].scanlist[j] ) {\n\t\t\tfor ( scan = g->shapes[i].scanlist[j]; scan; ) {\n\t\t\t    tscan = scan->next;\n\t\t\t    if ( scan ) free( scan );\n\t\t\t    scan = tscan;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif ( g->shapes[i].scanlist ) free( g->shapes[i].scanlist );\n\t    }\n\t    if ( g->shapes[i].pts ) free( g->shapes[i].pts );\n\t    if ( g->shapes[i].xv ) free( g->shapes[i].xv );\n\t}\n\tif ( g->masks ) free( g->masks );\n\tif ( g->shapes ) free( g->shape",
"s );\n\tif ( g->ybuf ) free( g->ybuf );\n\tif ( g->x0s ) free( g->x0s );\n\tif ( g->x1s ) free( g->x1s );\n\tif ( g ) free( g );\n#endif\n\treturn NULL;\n    }\n    else {\n\t/* do the filtering on each event */\n\tfor ( rptr = rbuf, eptr = ebuf; ne--; rptr++, eptr += esize ) {\n\t    g->rid = 0;\n#if DO_FILTER_SWAP\n\t    memset( _swf, 0, EVSIZE );\n#endif\n\t    *rptr = ( ( FILTER ) ? ( g->rid ? g->rid : -1 ) : 0 );\n\t}\n\treturn ( void * ) g;\n    }\n}\n\nint\nmain(\n    int argc,\n    char **argv\n ) {\n    int i;\n#if HAVE_MINGW32==0\n    int pipes[4];\n#endif\n    int get, got;\n#if DO_FILTER_SWAP\n    int sgot;\n#endif\n    int n;\n    int *rbuf;\n    char *ebuf, *etop;\n    char *s = NULL, *t = NULL, *u = NULL;\n    void *g = NULL;\n#if USE_WIN32\n    HANDLE hStdin, hStdout;\n    DWORD dwRead, dwWritten;\n#endif\n\n    /* Launch() sometimes rearranges passed pipes to be stdin/stdout */\n#if HAVE_MINGW32==0\n    if ( ( s = getenv( \"LAUNCH_PIPES\" ) ) ) {\n\tt = ( char * ) strdup( s );\n\tfor ( i = 0, u = ( char * ) strtok( t, \",\" ); i < 4 && u;\n\t      i++, u = ( ",
"char * ) strtok( NULL, \",\" ) ) {\n\t    pipes[i] = atoi( u );\n\t}\n\tif ( t ) free( t );\n\tif ( i < 4 ) return ( 1 );\n\tclose( pipes[0] );\n\tclose( pipes[3] );\n\tdup2( pipes[2], 0 );\n\tclose( pipes[2] );\n\tdup2( pipes[1], 1 );\n\tclose( pipes[1] );\n    }\n#endif\n\n#if USE_WIN32\n    hStdout = GetStdHandle( STD_OUTPUT_HANDLE );\n    hStdin = GetStdHandle( STD_INPUT_HANDLE );\n    if ( ( hStdout == INVALID_HANDLE_VALUE )\n         || ( hStdin == INVALID_HANDLE_VALUE ) ) {\n\tunlink( argv[0] );\n\treturn 0;\n    }\n#endif\n\n    /* read and filter events */\n#if USE_WIN32\n    while ( ( ReadFile( hStdin, &get, sizeof( int ), &dwRead, NULL ) > 0 ) &&\n\t    ( dwRead == sizeof( int ) ) ) {\n#else\n    while ( read( 0, &get, sizeof( int ) ) == sizeof( int ) ) {\n#endif\n#if DO_FILTER_SWAP\n\tswitch ( sizeof( int ) ) {\n\t    case 2:\n\t\t_sw2( ( char * ) &get, 2, NULL, 0 );\n\t\tbreak;\n\t    case 4:\n\t\t_sw4( ( char * ) &get, 4, NULL, 0 );\n\t\tbreak;\n\t    case 8:\n\t\t_sw8( ( char * ) &get, 8, NULL, 0 );\n\t\tbreak;\n\t}\n#endif\n\tebuf = ( char * ) calloc( get, sizeof( char",
" ) );\n#if USE_WIN32\n\tfor ( n = 0, etop = ebuf; get > 0; etop += got, get -= dwRead ) {\n\t    if ( ( ReadFile( hStdin, etop, get, &dwRead, NULL ) == FALSE )\n\t         || ( dwRead == 0 ) )\n\t\tbreak;\n\t    n += dwRead;\n\t}\n#else\n\tfor ( n = 0, etop = ebuf; get > 0; etop += got, get -= got ) {\n\t    if ( ( got = read( 0, etop, get ) ) <= 0 )\n\t\tbreak;\n\t    n += got;\n\t}\n#endif\n\tn /= EVSIZE;\n\t/* allocate return value buffer */\n\trbuf = ( int * ) calloc( n, sizeof( int ) );\n\t/* filter events, with results going into rbuf */\n\tg = EVFILTRTN( g, ebuf, n, EVSIZE, rbuf );\n\t/* write results */\n\tgot = n * sizeof( int );\n#if DO_FILTER_SWAP\n\tsgot = got;\n\tswitch ( sizeof( int ) ) {\n\t    case 2:\n\t\t_sw2( ( char * ) &sgot, 2, NULL, 0 );\n\t\tbreak;\n\t    case 4:\n\t\t_sw4( ( char * ) &sgot, 4, NULL, 0 );\n\t\tbreak;\n\t    case 8:\n\t\t_sw8( ( char * ) &sgot, 8, NULL, 0 );\n\t\tbreak;\n\t}\n#if USE_WIN32\n\tWriteFile( hStdout, &sgot, sizeof( int ), &dwWritten, NULL );\n#else\n\twrite( 1, &sgot, sizeof( int ) );\n#endif\n#else\n#if USE_WIN32\n\tWriteFile( hStdout, &go",
"t, sizeof( int ), &dwWritten, NULL );\n#else\n\twrite( 1, &got, sizeof( int ) );\n#endif\n#endif\n#if DO_FILTER_SWAP\n\tswitch ( sizeof( int ) ) {\n\t    case 2:\n\t\t_sw2( ( char * ) rbuf, got, NULL, 0 );\n\t\tbreak;\n\t    case 4:\n\t\t_sw4( ( char * ) rbuf, got, NULL, 0 );\n\t\tbreak;\n\t    case 8:\n\t\t_sw8( ( char * ) rbuf, got, NULL, 0 );\n\t\tbreak;\n\t}\n#endif\n#if USE_WIN32\n\tWriteFile( hStdout, rbuf, got, &dwWritten, NULL );\n#else\n\twrite( 1, rbuf, got );\n#endif\n\tif ( ebuf ) free( ebuf );\n\tif ( rbuf ) free( rbuf );\n    }\n    EVFILTRTN( g, NULL, -1, 0, NULL );\n    unlink( argv[0] );\n    return 0;\n}\n" }
};

