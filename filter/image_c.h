
#include "chunked.h"

ChunkedString IMAGE_C = {
  10,
  { "/* for TEST: gcc -DTEST -g -o foo imfilter.c imregions.o -lm */\n#ifdef TEST\n#include <stdio.h>\n#include <math.h>\n#define IMFILTRTN _FilterImage\n#define NMASK 0\n#define MASKDIM 0\n#define _masks NULL\n#define NSHAPE 2\n#define NREGION 2\n#define FILTER ((imcircle(g,1,1,1,4,(double)x,(double)y,8.0,8.0,5.0)))&&(imcircle(g,2,2,0,1,(double)x,(double)y,8.0,8.0,3.0))\n#define FILTSTR \"((imcircle(g,1,1,1,4,(double)x,(double)y,8.0,8.0,5.0)))&&(imcircle(g,2,2,0,1,(double)x,(double)y,8.0,8.0,3.0))\"\n#define FINIT imcirclei(g,1,1,1,4,(double)x,(double)y,8.0,8.0,5.0);imcirclei(g,2,2,0,1,(double)x,(double)y,8.0,8.0,3.0);\n#include \"regions.h\"\n#endif\n\n/* these are global for use with special region routines */\nFilterMask masks = NULL;        /* array valid region masks for one row */\nint maxmask;                    /* max masks allocated thus far */\nint nmask;                      /* number of mask segments */\nint nreg;                       /* number of regions in this set of rows */\nint rid;                        /* first valid",
" region for current pixel */\nint x, y;                       /* current row and column */\nint rlen;                       /* length of temp region buf */\nint *rbuf;                      /* temp region flags */\nint *rptr;                      /* pointer into region buffer */\n\nvoid\nincnmask(\n    void\n ) {\n    int omax;\n    nmask++;\n    if ( nmask >= maxmask ) {\n\tomax = maxmask;\n\tmaxmask += MASKINC;\n\tmasks = ( FilterMask ) realloc( masks, maxmask * sizeof( FilterMaskRec ) );\n\tmemset( masks + omax, 0, ( maxmask - omax ) * sizeof( FilterMaskRec ) );\n    }\n}\n\nFilterMask\nIMFILTRTN(\n    int txmin,\n    int txmax,\n    int tymin,\n    int tymax,\n    int tblock,\n    int *got\n ) {\n    int i, j;\n    int fieldonly;\n    GFilt g;\n    Scan scan, tscan;\n\n    /* make sure we have something to process */\n    if ( NSHAPE <= 0 ) {\n\t*got = 0;\n\treturn NULL;\n    }\n    /* allocate space for the globals */\n    g = ( GFilt ) calloc( 1, sizeof( GFiltRec ) );\n    /* see if we have only the field shape */\n    fieldonly = ( NSHAPE == 1 ) && s",
"trstr( FILTSTR, \"field\" );\n    /* allocate region records */\n    g->nshapes = NSHAPE;\n    g->maxshapes = ( NSHAPE * ( XSNO + 1 ) ) + 1;\n    g->shapes = ( Shape ) calloc( g->maxshapes, sizeof( ShapeRec ) );\n    /* make sure we start at 1 */\n    g->block = max( 1, tblock );\n    g->xmin = max( 1, txmin );\n    g->xmax = txmax;\n    g->ymin = max( 1, tymin );\n    g->ymax = tymax;\n    /* get x and y limits on subsection */\n    g->x0 = 1;\n    g->y0 = 1;\n    g->x1 = ( g->xmax - g->xmin ) / g->block + 1;\n    g->y1 = ( g->ymax - g->ymin ) / g->block + 1;\n    /* allocate a temp region buffer */\n    rlen = g->x1 - g->x0 + 1;\n    rbuf = ( int * ) calloc( rlen + 1, sizeof( int ) );\n    /* allocate an array of masks, which will be written to caller */\n    maxmask = MASKINC;\n    masks = ( FilterMask ) calloc( maxmask, sizeof( FilterMaskRec ) );\n    /* seed the first region mask value */\n    nmask = 0;\n    masks[nmask].region = 0;\n    /* keep track of how many hits we had for this set of rows */\n    nreg = 0;\n    /* allocate a",
" buffer for valid y row flags */\n    g->ybuf = ( int * ) calloc( g->y1 + 1, sizeof( int ) );\n    g->x0s = ( int * ) calloc( g->y1 + 1, sizeof( int ) );\n    g->x1s = ( int * ) calloc( g->y1 + 1, sizeof( int ) );\n    /* seed impossible values for x limits */\n    for ( i = 0; i <= g->y1; i++ ) g->x0s[i] = g->x1;\n    for ( i = 0; i <= g->y1; i++ ) g->x1s[i] = g->x0;\n    /* save image mask values */\n    if ( NMASK ) {\n\tg->nmask = NMASK;\n\tg->maskdim = MASKDIM;\n\tg->masks = _masks;\n    }\n    /* initialize ybuf */\n    FINIT;\n    /* process all valid rows */\n    for ( y = g->y0; y <= g->y1; y++ ) {\n\tif ( fieldonly ) {\n\t    /* inc the mask count, (extend mask array, if necessary) */\n\t    masks[nmask].region = 1;\n\t    masks[nmask].y = y - g->y0 + 1;\n\t    masks[nmask].xstart = 1;\n\t    masks[nmask].xstop = ( g->x1 - g->x0 + 1 );\n\t    incnmask(  );\n\t    continue;\n\t}\n\tif ( g->ybuf[y] ) {\n\t    /* to start this line, we make a seed mask with no region */\n\t    if ( masks[nmask].region ) {\n\t\t/* inc the mask count, (extend mask a",
"rray, if necessary) */\n\t\tincnmask(  );\n\t\tmasks[nmask].region = 0;\n\t    }\n\t    /* process each pixel in this row where there is a region */\n\t    for ( x = g->x0s[y], rptr = &rbuf[1 + ( g->x0s[y] - g->x0 )];\n\t          x <= g->x1s[y]; x++, rptr++ ) {\n\t\t/* get filter result, which is the region id or 0 */\n\t\tg->rid = 0;\n\t\tif ( FILTER ) {\n\t\t    /* never change a region id to a -1 */\n\t\t    if ( *rptr == 0 ) {\n\t\t\tnreg++;\n\t\t\t*rptr = g->rid ? g->rid : -1;\n\t\t    }\n\t\t    /* but always overwrite a -1 */\n\t\t    else if ( ( *rptr == -1 ) && ( g->rid > 0 ) ) {\n\t\t\t*rptr = g->rid;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\t/* if we have processed a row, make up the segments */\n\tif ( nreg ) {\n\t    for ( i = 1; i <= rlen; i++ ) {\n\t\tif ( rbuf[i] != masks[nmask].region ) {\n\t\t    /* if previous was non-zero region, finish it and bump to next */\n\t\t    if ( masks[nmask].region ) {\n\t\t\tmasks[nmask].xstop = i - 1;\n\t\t\t/* inc the mask count, (extend mask array, if necessary) */\n\t\t\tincnmask(  );\n\t\t    }\n\t\t    masks[nmask].y = y - g->y0 + 1;\n\t\t    masks[nmask]",
".region = rbuf[i];\n\t\t    masks[nmask].xstart = i;\n\t\t}\n\t    }\n\t    /* finish last non-zero segment, inc number of mask segs */\n\t    if ( masks[nmask].region ) {\n\t\tmasks[nmask].xstop = ( g->x1 - g->x0 + 1 );\n\t\t/* inc the mask count, (extend mask array, if necessary) */\n\t\tincnmask(  );\n\t    }\n\t    /* reset counters for next set of rows */\n\t    ( void ) memset( rbuf, 0, ( rlen + 1 ) * sizeof( int ) );\n\t    rptr = rbuf;\n\t    nreg = 0;\n\t}\n    }\n    /* free buffers */\n    if ( rbuf ) free( rbuf );\n    /* free region information */\n    if ( g ) {\n\tfor ( i = 0; i < g->maxshapes; i++ ) {\n\t    if ( g->shapes[i].scanlist ) {\n\t\tfor ( j = 0; j <= g->y1; j++ ) {\n\t\t    if ( g->shapes[i].scanlist[j] ) {\n\t\t\tfor ( scan = g->shapes[i].scanlist[j]; scan; ) {\n\t\t\t    tscan = scan->next;\n\t\t\t    free( scan );\n\t\t\t    scan = tscan;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tfree( g->shapes[i].scanlist );\n\t    }\n\t    if ( g->shapes[i].pts ) free( g->shapes[i].pts );\n\t    if ( g->shapes[i].xv ) free( g->shapes[i].xv );\n\t}\n\tif ( g->masks ) free( g->masks );\n\tif ",
"( g->shapes ) free( g->shapes );\n\tif ( g->ybuf ) free( g->ybuf );\n\tif ( g->x0s ) free( g->x0s );\n\tif ( g->x1s ) free( g->x1s );\n\tif ( g ) free( g );\n    }\n    /* return mask info */\n    *got = nmask;\n    return masks;\n}\n\nint\nmain(\n    int argc,\n    char **argv\n ) {\n    int i;\n    int get, got;\n#if DO_FILTER_SWAP\n    int sgot;\n#endif\n#if HAVE_MINGW32==0\n    int pipes[4];\n#endif\n    int txmin, txmax, tymin, tymax, tblock;\n    char tbuf[SZ_LINE];\n    char *s = NULL, *t = NULL, *u = NULL;\n#if USE_WIN32\n    HANDLE hStdin, hStdout;\n    DWORD dwRead, dwWritten;\n#endif\n\n    /* Launch() sometimes rearranges passed pipes to be stdin/stdout */\n#if HAVE_MINGW32==0\n    if ( ( s = getenv( \"LAUNCH_PIPES\" ) ) ) {\n\tt = ( char * ) strdup( s );\n\tfor ( i = 0, u = ( char * ) strtok( t, \",\" ); i < 4 && u;\n\t      i++, u = ( char * ) strtok( NULL, \",\" ) ) {\n\t    pipes[i] = atoi( u );\n\t}\n\tif ( t ) free( t );\n\tif ( i < 4 ) return ( 1 );\n\tclose( pipes[0] );\n\tclose( pipes[3] );\n\tdup2( pipes[2], 0 );\n\tclose( pipes[2] );\n\tdup2( pipes[1], ",
"1 );\n\tclose( pipes[1] );\n    }\n#endif\n\n#if USE_WIN32\n    hStdout = GetStdHandle( STD_OUTPUT_HANDLE );\n    hStdin = GetStdHandle( STD_INPUT_HANDLE );\n    if ( ( hStdout == INVALID_HANDLE_VALUE )\n         || ( hStdin == INVALID_HANDLE_VALUE ) ) {\n\tunlink( argv[0] );\n\treturn 0;\n    }\n#endif\n\n    /* process requests for region information for sections of the image */\n#ifdef TEST\n    while ( fgets( tbuf, SZ_LINE, stdin ) ) {\n#else\n#if USE_WIN32\n    while ( ( ReadFile( hStdin, &get, sizeof( int ), &dwRead, NULL ) !=\n\t      FALSE ) && ( dwRead == sizeof( int ) ) ) {\n#else\n    while ( read( 0, &get, sizeof( int ) ) == sizeof( int ) ) {\n#endif\n#if DO_FILTER_SWAP\n\tswitch ( sizeof( int ) ) {\n\t    case 2:\n\t\t_sw2( ( char * ) &get, 2, NULL, 0 );\n\t\tbreak;\n\t    case 4:\n\t\t_sw4( ( char * ) &get, 4, NULL, 0 );\n\t\tbreak;\n\t    case 8:\n\t\t_sw8( ( char * ) &get, 8, NULL, 0 );\n\t\tbreak;\n\t}\n#endif\n#if USE_WIN32\n\tif ( ( ReadFile( hStdin, tbuf, get, &dwRead, NULL ) == FALSE )\n\t     || ( dwRead != get ) )\n\t    break;\n#else\n\tif ( read( 0, t",
"buf, get ) != get )\n\t    break;\n#endif\n#endif /* #ifdef TEST */\n\tif ( sscanf( tbuf, \"%d %d %d %d %d\", &txmin, &txmax, &tymin, &tymax, &tblock ) != 5 ) {\n\t    break;\n\t}\n\tmasks = IMFILTRTN( txmin, txmax, tymin, tymax, tblock, &got );\n#ifdef TEST\n\t/* display segments for debugging */\n\tfprintf( stdout, \"nmask=%d\\n\", nmask );\n\tfor ( i = 0; i < nmask; i++ ) {\n\t    fprintf( stdout, \"region: %d\\tx: (%d,%d)\\ty: %d\\n\",\n\t             masks[i].region, masks[i].xstart, masks[i].xstop, masks[i].y );\n\t}\n\tfflush( stdout );\n#else\n\t/* calculate size of data we will write */\n\tgot = got * sizeof( FilterMaskRec );\n#if DO_FILTER_SWAP\n\tsgot = got;\n\tswitch ( sizeof( int ) ) {\n\t    case 2:\n\t\t_sw2( ( char * ) &sgot, 2, NULL, 0 );\n\t\tbreak;\n\t    case 4:\n\t\t_sw4( ( char * ) &sgot, 4, NULL, 0 );\n\t\tbreak;\n\t    case 8:\n\t\t_sw8( ( char * ) &sgot, 8, NULL, 0 );\n\t\tbreak;\n\t}\n#if USE_WIN32\n\tWriteFile( hStdout, &sgot, sizeof( int ), &dwWritten, NULL );\n#else\n\twrite( 1, &sgot, sizeof( int ) );\n#endif\n#else\n#if USE_WIN32\n\tWriteFile( hStdout, &got, si",
"zeof( int ), &dwWritten, NULL );\n#else\n\twrite( 1, &got, sizeof( int ) );\n#endif\n#endif\n#if DO_FILTER_SWAP\n\tswitch ( sizeof( int ) ) {\n\t    case 2:\n\t\t_sw2( ( char * ) masks, got, NULL, 0 );\n\t\tbreak;\n\t    case 4:\n\t\t_sw4( ( char * ) masks, got, NULL, 0 );\n\t\tbreak;\n\t    case 8:\n\t\t_sw8( ( char * ) masks, got, NULL, 0 );\n\t\tbreak;\n\t}\n#endif\n#if USE_WIN32\n\tWriteFile( hStdout, masks, got, &dwWritten, NULL );\n#else\n\twrite( 1, masks, got );\n#endif\n#endif\n\t/* free mask records */\n\tif ( masks ) free( masks );\n    }\n#ifndef TEST\n    unlink( argv[0] );\n#endif\n    return 0;\n}\n" }
};

